#
#  Copyright 2019 The FATE Authors. All Rights Reserved.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import os
import pathlib

import click


@click.group()
def component():
    """
    Manipulate components: execute, list, generate describe file
    """


@component.command()
@click.option("--process-tag", required=False, help="unique id to identify this execution process")
@click.option("--config", required=False, type=click.File(), help="config path")
@click.option("--config-entrypoint", required=False, help="entrypoint to get config")
@click.option("--properties", "-p", multiple=True, help="properties config")
@click.option("--env-prefix", "-e", type=str, default="runtime.component_desc.", help="prefix for env config")
@click.option("--env-name", required=False, type=str, help="env name for config")
@click.option(
    "--execution-final-meta-path",
    type=click.Path(exists=False, dir_okay=False, writable=True, resolve_path=True),
    default=os.path.join(os.getcwd(), "execution_final_meta.json"),
    show_default=True,
    help="path for execution meta generated by component when execution finished",
)
def execute(process_tag, config, config_entrypoint, properties, env_prefix, env_name, execution_final_meta_path):
    "execute component_desc"
    if config is None and config_entrypoint is None and not properties and env_name is None:
        raise click.UsageError("at least one of config, config-entrypoint, properties, env-name should be provided")
    import logging

    from fate.components.core.spec.task import TaskConfigSpec

    # parse properties
    properties_items = {}
    properties_items.update(load_properties(properties))
    properties_items.update(load_properties_from_env(env_prefix))

    # parse config
    configs = {}
    load_config_from_env(configs, env_name)
    load_config_from_entrypoint(configs, config_entrypoint)
    load_config_from_file(configs, config)
    load_config_from_properties(configs, properties_items)

    task_config = TaskConfigSpec.parse_obj(configs)

    # install logger
    task_config.conf.logger.install()
    logger = logging.getLogger(__name__)
    logger.debug("logger installed")
    logger.debug(f"task config: {task_config}")

    from fate.components.entrypoint.component import execute_component_from_config

    os.makedirs(os.path.dirname(execution_final_meta_path), exist_ok=True)
    execute_component_from_config(task_config, execution_final_meta_path)


@component.command()
@click.option("--process-tag", required=True, help="unique id to identify this execution process")
@click.option("--config", required=False, type=click.File(), help="config path")
def cleanup(process_tag, config):
    from fate.components.core.spec.task import TaskCleanupConfigSpec
    from fate.components.entrypoint.component import cleanup_component_execution

    cleanup_component_execution(TaskCleanupConfigSpec.parse_obj(config))


def load_properties(properties) -> dict:
    properties_dict = {}
    for property_item in properties:
        k, v = property_item.split("=")
        k = k.strip()
        v = v.strip()
        properties_dict[k] = v
    return properties_dict


def load_properties_from_env(env_filter_prefix):
    import os

    properties_dict = {}
    if env_filter_prefix:
        env_prefix_size = len(env_filter_prefix)
        for k, v in os.environ.items():
            if k.startswith(env_filter_prefix):
                property_key = k[env_prefix_size:]
                if property_key:
                    properties_dict[property_key] = v
    return properties_dict


def load_config_from_properties(configs, properties_dict):
    for k, v in properties_dict.items():
        lens_and_setter = configs, None

        def _setter(d, k):
            def _set(v):
                d[k] = v

            return _set

        for s in k.split("."):
            lens, _ = lens_and_setter
            if not s.endswith("]"):
                print("in", lens)
                if lens.get(s) is None:
                    lens[s] = {}
                lens_and_setter = lens[s], _setter(lens, s)
            else:
                name, index = s.rstrip("]").split("[")
                index = int(index)
                if lens.get(name) is None:
                    lens[name] = []
                lens = lens[name]
                if (short_size := index + 1 - len(lens)) > 0:
                    lens.extend([None] * short_size)
                    lens[index] = {}
                lens_and_setter = lens[index], _setter(lens, index)
        _, setter = lens_and_setter
        if setter is not None:
            setter(v)


def load_config_from_file(configs, config_file):
    from ruamel import yaml

    if config_file is not None:
        configs.update(yaml.safe_load(config_file))
    return configs


def load_config_from_entrypoint(configs, config_entrypoint):
    import requests

    if config_entrypoint is not None:
        try:
            resp = requests.get(config_entrypoint).json()
            configs.update(resp["config"])
        except:
            pass
    return configs


def load_config_from_env(configs, env_name):
    import os

    from ruamel import yaml

    if env_name is not None and os.environ.get(env_name):
        configs.update(yaml.safe_load(os.environ[env_name]))
    return configs


@component.command()
@click.option("--name", required=True, help="name of component_desc")
@click.option("--save", type=click.File(mode="w", lazy=True), help="save desc output to specified file in yaml format")
def desc(name, save):
    "generate component_desc describe config"
    from fate.components.core import load_component

    cpn = load_component(name)
    if save:
        cpn.dump_yaml(save)
    else:
        print(cpn.dump_yaml())


@component.command()
@click.option("--name", type=str, required=True, help="component name")
@click.option("--role", type=str, required=True, help="component name")
@click.option("--stage", type=str, required=True, help="component name")
@click.option("--output-path", type=click.File("w", lazy=True), help="output path")
def artifact_type(name, role, stage, output_path):
    from fate.components.core import Role, Stage, load_component

    cpn = load_component(name)
    role = Role.from_str(role)
    stage = Stage.from_str(stage)
    if not stage.is_default:
        for stage_component in cpn.stage_components:
            if stage_component.name == stage.name:
                cpn = stage_component
                break
        else:
            raise ValueError(f"stage `{stage.name}` for component `{component.name}` not supported")

    if output_path:
        cpn.dump_runtime_io_yaml(role, stage, output_path)
    else:
        print(cpn.dump_runtime_io_yaml(role, stage, output_path))


@component.command()
@click.option("--save", type=click.File(mode="w", lazy=True), help="save desc output to specified file in yaml format")
def task_schema(save):
    "generate component_desc task config json schema"
    from fate.components.core.spec.task import TaskConfigSpec

    if save:
        save.write(TaskConfigSpec.schema_json())
    else:
        print(TaskConfigSpec.schema_json())


@component.command()
@click.option("--save", type=click.File(mode="w", lazy=True), help="save list output to specified file in json format")
def list(save):
    "list all components"
    from fate.components.core import list_components

    if save:
        import json

        json.dump(list_components(), save)
    else:
        print(list_components())
