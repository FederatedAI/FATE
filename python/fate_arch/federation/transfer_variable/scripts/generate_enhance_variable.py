#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
#  Copyright 2019 The FATE Authors. All Rights Reserved.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#
from itertools import combinations
from pathlib import Path

LICENSE = """\
#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
#  Copyright 2019 The FATE Authors. All Rights Reserved.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#

##########################################################
# Generated by {}
##########################################################
"""

IMPORTS = """
import typing
from typing import Union

from fate_arch.common import Party
from fate_arch.federation.transfer_variable import Variable
from fate_arch.session import get_latest_opened
"""

PROTOCOL = """\
class _VariableProtocol(object):

    def remote_parties(self,
                       obj,
                       parties: Union[typing.List[Party], Party],
                       suffix: Union[typing.Any, typing.Tuple] = tuple()):
        raise NotImplementedError()

    def get_parties(self,
                    parties: Union[typing.List[Party], Party],
                    suffix: Union[typing.Any, typing.Tuple] = tuple()) -> typing.List:
        raise NotImplementedError()

    @staticmethod
    def roles_to_parties(roles):
        party_info = get_latest_opened().parties
        return party_info.roles_to_parties(roles)
"""

ToFromTrait = """\
# noinspection PyAbstractClass
class _To{cap_name}(_VariableProtocol):
    def to_{lower_name}(self, obj, suffix):
        parties = self.roles_to_parties(["{lower_name}"])
        self.remote_parties(obj, parties, suffix)
    
    def to_kth_{lower_name}(self, obj, k, suffix):
        parties = self.roles_to_parties(["{lower_name}"])
        assert k < len(parties), f"index {{k}} out of range [0, {{len(parties) - 1}}]"
        self.remote_parties(obj, parties[k], suffix)


# noinspection PyAbstractClass
class _From{cap_name}(_VariableProtocol):
    def from_{lower_name}(self, suffix) -> typing.List:
        parties = self.roles_to_parties(["{lower_name}"])
        return self.get_parties(parties, suffix)

    def get_kth_{lower_name}(self, k, suffix) -> typing.Any:
        parties = self.roles_to_parties(["{lower_name}"])
        assert k < len(parties), f"index {{k}} out of range [0, {{len(parties) - 1}}]"
        results = self.get_parties(parties[k], suffix)
        return results[0]
"""

PAIR_TRAIT = """\
# noinspection PyAbstractClass
class _From{left}{right}(_From{left}, _From{right}):
    def from_guest_host(self, suffix) -> typing.List:
        parties = self.roles_to_parties(["{left_lower}", "{right_lower}"])
        return self.get_parties(parties, suffix)


# noinspection PyAbstractClass
class _To{left}{right}(_To{left}, _To{right}):
    def to_guest_host(self, obj, suffix):
        parties = self.roles_to_parties(["{left_lower}", "{right_lower}"])
        return self.remote_parties(obj, parties, suffix)
"""

UNION = """\
class {left_head}2{right_head}Variable(Variable, _From{left}, _To{right}):
    def __init__(self, name):
        super().__init__(name, src={src}, dst={dst})
"""

ROLES = ["Arbiter", "Guest", "Host"]


def main():
    dst = Path(__file__).parent.parent.joinpath("_generated_enhance_variable.py")
    with dst.open("w") as f:
        f.write(LICENSE.format(Path(__file__).relative_to(dst.parent)))
        f.write("\n")
        f.write(IMPORTS)
        f.write("\n\n")
        f.write(PROTOCOL)
        for role in ROLES:
            f.write("\n\n")
            f.write(ToFromTrait.format(cap_name=role.capitalize(), lower_name=role.lower()))

        for left, right in combinations(ROLES, 2):
            f.write("\n\n")
            f.write(PAIR_TRAIT.format(left=left, right=right, left_lower=left.lower(), right_lower=right.lower()))

        for left in ROLES:
            for right in ROLES:
                if left == right:
                    continue
                f.write("\n\n")
                f.write(UNION.format(left_head=left[0], right_head=right[0], left=left, right=right,
                                     src=(left.lower(),), dst=(right.lower(),)))

        for left in ROLES:
            for right in combinations(ROLES, 2):
                if left not in right:
                    f.write("\n\n")
                    f.write(UNION.format(left_head=left[0], right_head=f"{right[0][0]}{right[1][0]}",
                                         left=left, right=f"{right[0]}{right[1]}",
                                         src=(left.lower(),), dst=tuple(r.lower() for r in right)))
                    f.write("\n\n")
                    f.write(UNION.format(right_head=left[0], left_head=f"{right[0][0]}{right[1][0]}",
                                         right=left, left=f"{right[0]}{right[1]}",
                                         dst=(left.lower(),), src=tuple(r.lower() for r in right)))


if __name__ == '__main__':
    main()
